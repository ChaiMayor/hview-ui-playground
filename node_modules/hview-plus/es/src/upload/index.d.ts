declare const Upload: import("@hview-plus/utils").SFCWithInstall<import("vue").DefineComponent<{
    type: StringConstructor;
    multiple: BooleanConstructor;
    accept: StringConstructor;
    drag: BooleanConstructor;
    showFileList: BooleanConstructor;
}, {
    props: any;
    emits: (event: "getFilesList", ...args: any[]) => void;
    hIpt: import("vue").Ref<any>;
    fileArea: import("vue").Ref<any>;
    fileList: import("vue").Ref<{
        readonly lastModified: number;
        readonly name: string;
        readonly webkitRelativePath: string;
        readonly size: number;
        readonly type: string;
        arrayBuffer: () => Promise<ArrayBuffer>;
        slice: (start?: number, end?: number, contentType?: string) => Blob;
        stream: () => ReadableStream<Uint8Array>;
        text: () => Promise<string>;
    }[]>;
    previewImgList: import("vue").Ref<any[]>;
    showMask: import("vue").Ref<{
        valueOf: () => boolean;
    }>;
    isModalVisible: import("vue").Ref<{
        valueOf: () => boolean;
    }>;
    closeModal: () => void;
    modalImgUrl: import("vue").Ref<any>;
    modalName: import("vue").Ref<{
        [x: number]: string;
        toString: () => string;
        charAt: (pos: number) => string;
        charCodeAt: (index: number) => number;
        concat: (...strings: string[]) => string;
        indexOf: (searchString: string, position?: number) => number;
        lastIndexOf: (searchString: string, position?: number) => number;
        localeCompare: {
            (that: string): number;
            (that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;
        };
        match: {
            (regexp: string | RegExp): RegExpMatchArray;
            (matcher: {
                [Symbol.match](string: string): RegExpMatchArray;
            }): RegExpMatchArray;
        };
        replace: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
            (searchValue: {
                [Symbol.replace](string: string, replaceValue: string): string;
            }, replaceValue: string): string;
            (searchValue: {
                [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
            }, replacer: (substring: string, ...args: any[]) => string): string;
        };
        search: {
            (regexp: string | RegExp): number;
            (searcher: {
                [Symbol.search](string: string): number;
            }): number;
        };
        slice: (start?: number, end?: number) => string;
        split: {
            (separator: string | RegExp, limit?: number): string[];
            (splitter: {
                [Symbol.split](string: string, limit?: number): string[];
            }, limit?: number): string[];
        };
        substring: (start: number, end?: number) => string;
        toLowerCase: () => string;
        toLocaleLowerCase: (locales?: string | string[]) => string;
        toUpperCase: () => string;
        toLocaleUpperCase: (locales?: string | string[]) => string;
        trim: () => string;
        readonly length: number;
        substr: (from: number, length?: number) => string;
        valueOf: () => string;
        codePointAt: (pos: number) => number;
        includes: (searchString: string, position?: number) => boolean;
        endsWith: (searchString: string, endPosition?: number) => boolean;
        normalize: {
            (form: "NFC" | "NFD" | "NFKC" | "NFKD"): string;
            (form?: string): string;
        };
        repeat: (count: number) => string;
        startsWith: (searchString: string, position?: number) => boolean;
        anchor: (name: string) => string;
        big: () => string;
        blink: () => string;
        bold: () => string;
        fixed: () => string;
        fontcolor: (color: string) => string;
        fontsize: {
            (size: number): string;
            (size: string): string;
        };
        italics: () => string;
        link: (url: string) => string;
        small: () => string;
        strike: () => string;
        sub: () => string;
        sup: () => string;
        padStart: (maxLength: number, fillString?: string) => string;
        padEnd: (maxLength: number, fillString?: string) => string;
        trimEnd: () => string;
        trimStart: () => string;
        trimLeft: () => string;
        trimRight: () => string;
        matchAll: (regexp: RegExp) => IterableIterator<RegExpMatchArray>;
        replaceAll: {
            (searchValue: string | RegExp, replaceValue: string): string;
            (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
        };
        at: (index: number) => string;
        [Symbol.iterator]: () => IterableIterator<string>;
    }>;
    fileUpload: () => any;
    getFilesList: (e: Event) => void;
    delFile: (index: number) => void;
    previewImg: (files: any) => void;
    openMask: (index: number) => void;
    removeImg: (index: number) => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "getFilesList"[], "getFilesList", import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    type: StringConstructor;
    multiple: BooleanConstructor;
    accept: StringConstructor;
    drag: BooleanConstructor;
    showFileList: BooleanConstructor;
}>> & {
    onGetFilesList?: (...args: any[]) => any;
}, {
    multiple: boolean;
    drag: boolean;
    showFileList: boolean;
}>>;
export default Upload;
